#!/usr/bin/perl
#
# kindle_collect - read and write Amazon Kindle collections
#
# Copyright (C) 2011  Christian Garbs <mitch@cgarbs.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

use strict;
use warnings;

use Digest::SHA1 qw(sha1_hex);
use File::Find;
use JSON::Any;



### subroutines #################################################################

sub check_dir($)
{
    my $dir = shift;
    die "`$dir' does not exist\n"  unless -e $dir;
    die "`$dir' is no directory\n" unless -d $dir;
    
}

sub check_file($)
{
    my $file = shift;
    die "`$file' does not exist\n" unless -e $file;
    die "`$file' is no file\n"     unless -f $file;
    
}

sub help()
{
    print <<"EOF";

kindle_collect [ --read <DIR> | --write <DIR> ]

Read and write collection data from an Amazon Kindle.

<DIR>    The directory your Kindle is mounted to.
--read   Prints the current collection in an easy to edit format to
         stdout.
--write  Read this format from stdin and copies it to your Kindle,
         overwriting your existing collections.  You might want to
         backup system/collections.json beforehand.

This is mostly untested and might (but should and propably will not)
break your Kindle.

EOF
    ;
}

sub find_docs($)
{
    my $dir = shift;
    my %docs;
    find(sub
	 {
	     if ( -f $File::Find::name ) {
		 $File::Find::name =~ s,^$dir/,,;
		 $docs{ '*'.sha1_hex( "/mnt/us/documents/$File::Find::name") } = $File::Find::name;
	     };
	 }
	 , $dir);
    return %docs;
}



### MAIN ########################################################################

# check parameters

if ( @ARGV != 2 or ($ARGV[0] ne '--read' && $ARGV[0] ne '--write') ) {
    help();
    exit;
}

# check directories

my $rootdir = $ARGV[1];
check_dir $rootdir;

my $docdir = $rootdir.'/documents';
check_dir $docdir;

my $sysdir = $rootdir.'/system';
check_dir $sysdir;

my $colfile = $sysdir.'/collections.json';
check_file $colfile;



### READ ########################################################################

if ($ARGV[0] eq '--read') { ######## READ

    # parse collections file

    my $json;
    {
	local $\ = undef;
	open COL, '<', $colfile or die "can't open `$colfile': $!\n";
	$json = <COL>;
	close COL or die "can't close `$colfile': $!\n";
    }

    my $j = JSON::Any->new;
    my $cols = $j->decode($json);

    # find all documents
    
    my %docs = find_docs $docdir;

    # print collections
    
    my %hashes;
    foreach my $colname ( sort keys %{$cols} ) {

	my $col = $cols->{$colname};
	$colname =~ s/\@en-US$//;

	print "%% $colname\n";
	print "++ $col->{lastAccess} (" . localtime($col->{lastAccess}/1000) . ")\n";

	my @result;
	my $missing = 0;

	foreach my $item ( @{$col->{items}} ) {
	    if (exists $docs{$item}) {
		push @result, $docs{$item};
		push @{$hashes{$item}}, $colname;
	    } else {
		$missing++;
	    }
	}

	print "!\t$missing missing documents\n" if $missing;
	print "\t$_\n" foreach (sort @result);
	print "\n";

    }

    # print uncollected

    print "%% ___unsorted___\n";

    my @result;

    foreach my $hash (keys %docs) {

	if (! exists $hashes{$hash}) {
	    push @result, $docs{$hash};
	}

    }

    print "\t$_\n" foreach (sort @result);
    print "\n";
    
}



### WRITE #######################################################################

elsif ($ARGV[0] eq '--write') {

    # find all documents
    
    my %docs = find_docs $docdir;
    my %files;
    foreach (keys %docs) {
	$files{$docs{$_}} = $_;
    }

    # parse stdin
    
    my %cols;
    my $colname = '';
    
    while (my $line = <STDIN>) {

	chomp $line;
	$line =~ s/(\s+$|^\s+)//g;
	next if $line eq '';
	next if $line =~ /^!.*missing documents/;
		    
	if ($line =~ /^%%\s*(.*)$/) {
	    $colname = $1;
	    $cols{$colname}->{NAME} = $colname;

	} elsif ($line =~ /^\+\+\s*(\d+)/) {
	    $cols{$colname}->{LASTACCESS} = $1;

	} else {
	    if (exists $files{$line}) {
		push @{$cols{$colname}->{ITEMS}}, $files{$line};
	    } else {
		die "line $.:unkown document `$line' in collection `$colname'\n";
	    }
	}

    }

    die "input file messed up, collection name must precede all other lines\n" if exists $cols{''};

    # write JSON

    my $json;
    foreach my $col (values %cols) {
	next if $col->{NAME} eq '___unsorted___';
	$json->{"$col->{NAME}\@en-US"} = {
	    'lastAccess' => exists $col->{LASTACCESS} ? $col->{LASTACCESS} : time().'000',
	    'items' => exists $col->{ITEMS} ? $col->{ITEMS} : [],
	};
    }

    my $j = JSON::Any->new;
    open COL, '>', $colfile or die "can't open `$colfile': $!\n";
    print COL $j->encode($json);
    close COL or die "can't close `$colfile': $!\n";
 
}
